# äºŒå‰æŸ¥æ‰¾æ ‘ (æ ‘ADTè¿è½½ 3/13)

â—ï¸ **ã€NEWã€‘** â—ï¸

- 9-15:  [çº¢é»‘æ ‘ä»å…¥é—¨åˆ°çœ‹å¼€](https://leetcode.cn/circle/discuss/SwgIJV/)

è¿™æ˜¯å°ç™½ yuki æ¨å‡ºçš„ã€Œæ ‘ADTã€ç³»åˆ—æ–‡ç« çš„ç¬¬ 3 ç¯‡ (3/13) ã€‚

***

å®é™…ä¸Šæœ¬æ–‡æ˜¯ä¸ºäº†åç»­è®²è§£å¤šç§ **å¹³è¡¡äºŒå‰æ ‘** çš„å‰ç½®æ–‡ç« ï¼Œæœ€ç»ˆç›®çš„æ˜¯è®²è§£ **ã€Œçº¢é»‘æ ‘ã€** (å·²æ¨å‡ºï¼Œ[çº¢é»‘æ ‘ä»å…¥é—¨åˆ°çœ‹å¼€](https://leetcode.cn/circle/discuss/SwgIJV/))ã€‚

æœ¬æ–‡é‡ç‚¹åœ¨äºå±•ç°å¦‚ä½•è®¾è®¡ä¸€ä¸ª BST ç±»ï¼Œåˆ†æä¸»è¦æ–¹æ³•çš„ä»£ç å®ç°ï¼Œå¹¶ç»™å‡ºè¯¥ç±»çš„å®Œæ•´å®ç°ä»£ç ã€‚è¯»è€…å­¦ä¹ ä¹‹å **å¯ä»¥è‡ªå·±å†™å‡ºä¸€ä¸ªæ–¹æ³•è¾ƒä¸ºå®Œå¤‡çš„åŸºæœ¬ BST ç±»** ã€‚

***

yukiçš„å…¶ä»–æ–‡ç« å¦‚ä¸‹ï¼Œæ¬¢è¿é˜…è¯»æŒ‡æ­£ï¼

| æ–‡ç«                                                          | [å‘å¸ƒæ—¶é—´] å­—æ•°/è§ˆ/è—/èµ (~09-23)        |
| ------------------------------------------------------------ | ---------------------------------------- |
| [åå¤§æ’åºä»å…¥é—¨åˆ°å…¥èµ˜](https://leetcode.cn/circle/discuss/eBo9UB/)  ğŸ”¥ğŸ”¥ğŸ”¥ | [20220516]  2.5ä¸‡å­—/58.2kè§ˆ/3.5kè—/865èµ |
| [äºŒåˆ†æŸ¥æ‰¾ä»å…¥é—¨åˆ°å…¥ç¡](https://leetcode.cn/circle/discuss/ooxfo8/) ğŸ”¥ğŸ”¥ğŸ”¥ | [20220509]  2.3ä¸‡å­—/35.9kè§ˆ/2.1kè—/484èµ |
| [å¹¶æŸ¥é›†ä»å…¥é—¨åˆ°å‡ºé—¨](https://leetcode.cn/circle/discuss/qmjuMW/) ğŸ”¥ğŸ”¥ | [20220514]  1.2ä¸‡å­—/15.1kè§ˆ/924è—/279èµ  |
| [å›¾è®ºç®—æ³•ä»å…¥é—¨åˆ°æ”¾ä¸‹](https://leetcode.cn/circle/discuss/FyPTTM/) ğŸ”¥ğŸ”¥ | [20220617]  5.6ä¸‡å­—/17.3kè§ˆ/1.2kè—/341èµ |
| æ ‘ADTç³»åˆ— (é¢„è®¡13ç¯‡)                                         | ç³»åˆ—æ–‡ç« ï¼Œè¿è½½ä¸­                         |
| 3. [äºŒå‰æŸ¥æ‰¾æ ‘](https://leetcode.cn/circle/discuss/wPzlSb/)  | [20220801]  5åƒå­—                        |
| 4. [AVLæ ‘](https://leetcode.cn/circle/discuss/zbwD3p/)       | [20220817]  5åƒå­—                        |
| 5. [splayæ ‘](https://leetcode.cn/circle/discuss/BCK17f/)     | [20220817]  5åƒå­—                        |
| 6. [çº¢é»‘æ ‘ä»å…¥é—¨åˆ°çœ‹å¼€](https://leetcode.cn/circle/discuss/SwgIJV/) ğŸ”¥ğŸ¤¯ğŸ¤¯ğŸ¤¯ | [20220915]  3ä¸‡å­—/3.1kè§ˆ/186è—/52èµ      |
| 10. [æ ‘çŠ¶æ•°ç»„ä»å…¥é—¨åˆ°ä¸‹è½¦](https://leetcode.cn/circle/discuss/qGREiN/) ğŸ”¥ğŸ¤¯ | [20220722]  1.1ä¸‡å­—/3.9kè§ˆ/129è—/49èµ    |
| 11. [çº¿æ®µæ ‘ä»å…¥é—¨åˆ°æ€¥åœ](https://leetcode.cn/circle/discuss/H4aMOn/) ğŸ”¥ğŸ¤¯ | [20220726]  2.5ä¸‡å­—/4.8kè§ˆ/324è—/93èµ    |
| [å›¾è®ºç›¸å…³è¯æ˜ç³»åˆ—](https://leetcode.cn/circle/discuss/GV0JrV/) | ç³»åˆ—æ–‡ç«                                  |
| 1. [Dijkstraæ­£ç¡®æ€§è¯æ˜](https://leetcode.cn/circle/discuss/jJQn7V/) ğŸ¤¯ | [20220531]                               |
| 2. [Primæ­£ç¡®æ€§è¯æ˜](https://leetcode.cn/circle/discuss/VVEc8f/) ğŸ¤¯ | [20220919]                               |
| 3. [Bellman-FordåŠSPFAæ­£ç¡®æ€§è¯æ˜](https://leetcode.cn/circle/discuss/xeEwYl/) | [20220602]                               |
| 4. [Floydæ­£ç¡®æ€§è¯æ˜](https://leetcode.cn/circle/discuss/Nbzix4/) | [20220602]                               |
| 5. [æœ€å¤§æµæœ€å°å‰²å®šç†è¯æ˜](https://leetcode.cn/circle/discuss/tMIy36/) ğŸ¤¯ğŸ¤¯ | [20220719]                               |
| 6. [Edmonds-Karpå¤æ‚åº¦è¯æ˜](https://leetcode.cn/circle/discuss/tN3sZc/) ğŸ¤¯ğŸ¤¯ | [20220515]                               |
| 7. [Dinicå¤æ‚åº¦è¯æ˜](https://leetcode.cn/circle/discuss/T9Xa1R/) ğŸ¤¯ğŸ¤¯ | [20220531]                               |



***

[TOC]

***

## äºŒå‰æŸ¥æ‰¾æ ‘

[äºŒå‰æŸ¥æ‰¾æ ‘ / äºŒå‰æœç´¢æ ‘ / äºŒå‰æ’åºæ ‘ (Binary Search Tree / Binary Sort Tree, BST) ](https://en.wikipedia.org/wiki/Binary_search_tree): å¯¹äºä¸€æ£µäºŒå‰æ ‘ï¼Œæ¯ä¸ªç»“ç‚¹å­˜æœ‰ä¸€ä¸ªå¯ç”¨äºæ¯”è¾ƒçš„æ•°æ®é¡¹ï¼Œè§„å®šç»“ç‚¹ $x$ çš„å·¦å­æ ‘ä¸­æ‰€æœ‰ç»“ç‚¹çš„æ•°æ®é¡¹å°äº $x$ çš„æ•°æ®é¡¹ï¼Œè€Œ $x$ çš„å³å­æ ‘ä¸­æ‰€æœ‰ç»“ç‚¹çš„æ•°æ®é¡¹å¤§äº $x$ çš„æ•°æ®é¡¹ï¼Œè¿™æ ·çš„äºŒå‰æ ‘å³ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘ã€‚å¯¹äºæœ‰ $n$ ä¸ªå…ƒç´ çš„äºŒå‰æ ‘ï¼Œå‡è®¾æ ‘é«˜å¹³è¡¡ï¼Œåˆ™æ ¹æ®å‰é¢çš„æ€§è´¨å¯çŸ¥å…¶é«˜åº¦ä¸º $logn$ ï¼Œæˆ‘ä»¬å°†èƒ½å¤Ÿé€šè¿‡å…¶ç»“ç‚¹æ•°æ®é¡¹æœ‰åºçš„ç‰¹ç‚¹ï¼Œä»¥ç±»ä¼¼äºŒåˆ†æŸ¥æ‰¾çš„æ ‘ä¸Šçš„ **äºŒåˆ†æ“ä½œ** å®ç° $O(logn)$ å¹³å‡æ—¶é—´å¤æ‚åº¦çš„æ’å…¥ï¼ŒæŸ¥æ‰¾å’Œåˆ é™¤ç­‰æ“ä½œã€‚BST å†…å®¹éå¸¸ä¸°å¯Œï¼Œä¸‹é¢æˆ‘ä»¬å…ˆä»‹ç»éè‡ªå¹³è¡¡çš„ **åŸºæœ¬ BST** ï¼Œç”±äºåŸºæœ¬BSTæ ‘é«˜ä¸ä¿è¯å¹³è¡¡ï¼Œæ ‘ä¸Šæ“ä½œçš„å¤æ‚åº¦æ— æ³•ä¿è¯ä¸º $O(logn)$ ï¼Œå› æ­¤å¼•å…¥ **å¹³è¡¡ BST** ã€‚æˆ‘ä»¬å°†ä¼šè¯¦ç»†å‡ ç§ä¸åŒçš„å¹³è¡¡ BST å®ç°ã€‚

æ ¹æ®å®šä¹‰å¯çŸ¥ä¸‹å›¾ä¸­åªæœ‰å·¦ä¾§çš„æ ‘æ˜¯ BST ï¼Œå³ä¾§çš„æ ‘ä¸­ç»“ç‚¹ 7 ä¸ 6 ä¸æ»¡è¶³ BST çš„ç»“ç‚¹é¡ºåºæ€§è´¨ï¼Œè‹¥ç»“ç‚¹ 7 æ˜¯ç»“ç‚¹ 8 çš„å·¦å­ç»“ç‚¹ï¼Œåˆ™ä¸º BSTã€‚

![image.png](https://pic.leetcode-cn.com/1656840556-GvQFIZ-image.png)

â€» åº”ç”¨äºŒå‰æŸ¥æ‰¾æ ‘å®ç°çš„æ•°æ®ç»“æ„ä¸€èˆ¬ä¸º $set$ æˆ– $map$ï¼Œè‹¥ä¸º $set$ (ä¾‹å¦‚ Java ä¸­çš„ $TreeSet$)ï¼Œåˆ™ä¸ä¼šå­˜å‚¨ç›¸åŒæ•°æ®é¡¹ï¼Œè‹¥ä¸º $map$ (ä¾‹å¦‚ Java ä¸­çš„ $TreeMap$)ï¼Œåˆ™ä¸ä¼šå­˜å‚¨ç›¸åŒ $key$ å€¼ã€‚è‹¥è¦æ±‚ä¿å­˜ç›¸åŒå€¼ï¼Œå¯ä»¥é‡‡ç”¨é“¾è¡¨æˆ–å°†ç›¸åŒå€¼çœ‹ä½œå°äºæˆ–å¤§äºæ¥å¤„ç†ï¼Œæœ¬æ–‡ä»¥åŠåç»­è®²è§£çš„æ‰€æœ‰äºŒå‰æŸ¥æ‰¾æ ‘å‡ä¸ä¿å­˜ç›¸åŒå€¼ã€‚ 



> æ ¹æ® Wiki è¯æ¡ï¼Œæ­¤æ•°æ®ç»“æ„åœ¨ 1960 å¹´ä»£ç”±å¤šäººç‹¬ç«‹æå‡ºã€‚
>
> The binary search tree algorithm was discovered independently by several researchers, including P.F. Windley, [Andrew Donald Booth](https://en.wikipedia.org/wiki/Andrew_Donald_Booth), [Andrew Colin](https://en.wikipedia.org/wiki/Andrew_Colin), [Thomas N. Hibbard](https://en.wikipedia.org/wiki/Thomas_N._Hibbard). 

<br />

### åŸºæœ¬BST

åŸºæœ¬ BST å³åªä¿æŒ BST ç»“ç‚¹æ•°æ®é¡¹å¤§å°å…³ç³»æ€§è´¨ï¼Œè€Œä¸ç»´æŠ¤æ ‘é«˜å¹³è¡¡çš„ **éå¹³è¡¡ BST** ã€‚æ‰€è°“ã€Œå¹³è¡¡ã€ï¼ŒæŒ‡æ ‘çš„å½¢æ€ç±»ä¼¼ç­‰è…°ä¸‰è§’å½¢ï¼Œä»æ ¹ç»“ç‚¹åˆ°ä»»æ„å¶å­ç»“ç‚¹çš„è·¯å¾„é•¿åº¦éƒ½æ˜¯ç¨³å®šçš„ $O(logn)$ ï¼Œæ›´ä¸¥æ ¼çš„å®šä¹‰æ˜¯ **ã€Œä»»æ„ç»“ç‚¹çš„å·¦å³å­æ ‘é«˜å·®ä¸è¶…è¿‡ 1ã€** ï¼Œå¦‚æ­¤å³èƒ½ä¿è¯å¯¹ç»“ç‚¹çš„å¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º $O(logn)$ ã€‚

åŸºæœ¬BSTçš„å®šä¹‰ååˆ†ç®€å•ï¼Œæˆ‘ä»¬ç›´æ¥ç»™å‡ºå®ƒçš„ç±»çš„å®ç°æ¶æ„ï¼Œå¹¶ä»‹ç»å…¶ä¸­çš„ä¸»è¦æ–¹æ³•ï¼Œç„¶åå†åˆ†æä¸»è¦æ“ä½œçš„æ—¶ç©ºå¤æ‚åº¦ã€‚

> æœ¬èŠ‚å†…å®¹ä¸º Mark Allen Weiss æ‰€è‘— [æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æï¼šJavaè¯­è¨€æè¿°](https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf) ç›¸å…³ç« èŠ‚çš„æ•´ç†å’Œæ€»ç»“ã€‚ä»£ç äº¦æ¥è‡ªè¯¥ä¹¦ï¼Œç•¥ä½œæ”¹åŠ¨ã€‚

<br />

#### åŸºæœ¬BSTç±»æ¶æ„

ä»¥ä¸‹æ˜¯åŸºæœ¬ BST ç±» ($MyTreeSet$) æ¶æ„ã€‚

| ç±»æˆå‘˜/æ–¹æ³•                                | æè¿°                                |
| ------------------------------------------ | ----------------------------------- |
| `private Node<E> root`                     | å”¯ä¸€å­—æ®µï¼Œæ ¹ç»“ç‚¹                    |
| `public MyTreeSet()`                       | æ— å‚æ„é€ å™¨                          |
| `public void clear()`                      | æ ‘ç½®ç©º                              |
| `public boolean isEmpty()`                 | æ ‘åˆ¤ç©º                              |
| `public void add(E e)`                     | æ’å…¥ç»“ç‚¹é©±åŠ¨æ–¹æ³•                    |
| `public void remove(E e)`                  | åˆ é™¤ç»“ç‚¹é©±åŠ¨æ–¹æ³•                    |
| `public E first()`                         | æŸ¥æ‰¾æœ€å°ç»“ç‚¹é©±åŠ¨æ–¹æ³•                |
| `public E last()`                          | æŸ¥æ‰¾æœ€å¤§ç»“ç‚¹é©±åŠ¨æ–¹æ³•                |
| `public E floor(E e)`                      | æŸ¥æ‰¾å°äºç­‰äº $e$ çš„æœ€å¤§å…ƒç´ é©±åŠ¨æ–¹æ³• |
| `public E ceiling(E e)`                    | æŸ¥æ‰¾å¤§äºç­‰äº $e$ çš„æœ€å°å…ƒç´ é©±åŠ¨æ–¹æ³• |
| `public E lower(E e)`                      | æŸ¥æ‰¾ä¸¥æ ¼å°äº $e$ çš„æœ€å¤§å…ƒç´ é©±åŠ¨æ–¹æ³• |
| `public E higher(E e)`                     | æŸ¥æ‰¾ä¸¥æ ¼å¤§äº $e$ çš„æœ€å°å…ƒç´ é©±åŠ¨æ–¹æ³• |
| `public boolean contains(E e)`             | ç»“ç‚¹å­˜åœ¨åˆ¤å®šé©±åŠ¨æ–¹æ³•                |
| `public void printTree()`                  | ä¸­åºéå†æ‰“å°æ ‘çš„é©±åŠ¨æ–¹æ³•            |
| `public int size()`                        | æ±‚æ ‘å¤§å°é©±åŠ¨æ–¹æ³•                    |
| `public int height()`                      | æ±‚æ ‘é«˜é©±åŠ¨æ–¹æ³•                      |
| `private Node<E> add(E e, Node<E> t)`      | æ’å…¥ç»“ç‚¹                            |
| `private Node<E> remove(E e, Node<E> t)`   | åˆ é™¤ç»“ç‚¹(æ‡’æƒ°åˆ é™¤)                  |
| `private Node<E> first(Node<E> t)`         | è¿”å›æ ‘çš„æœ€å°ç»“ç‚¹                    |
| `private Node<E> last(Node<E> t)`          | è¿”å›æ ‘çš„æœ€å¤§ç»“ç‚¹                    |
| `private Node floor(Node<E> x, E e)`       | æŸ¥æ‰¾å°äºç­‰äº $e$ çš„æœ€å¤§å…ƒç´          |
| `private Node<E> ceiling(Node<E> x, E e)`  | æŸ¥æ‰¾å¤§äºç­‰äº $e$ çš„æœ€å°å…ƒç´          |
| `private Node lower(Node<E> x, E e)`       | æŸ¥æ‰¾ä¸¥æ ¼å°äº $e$ çš„æœ€å¤§å…ƒç´          |
| `private Node<E> higher(Node<E> x, E e)`   | æŸ¥æ‰¾ä¸¥æ ¼å¤§äº $e$ çš„æœ€å°å…ƒç´          |
| `private boolean contains(E e, Node<E> t)` | åˆ¤æ–­æ ‘ä¸­æ˜¯å¦æœ‰æŒ‡å®šå…ƒç´ çš„ç»“ç‚¹        |
| `private void printTree(Node<E> t)`        | ä¸­åºéå†æ‰“å°æ ‘                      |
| `private int height(Node<E> t)`            | æ±‚ä»¥ $t$ ä¸ºæ ¹ç»“ç‚¹çš„æ ‘é«˜             |
| `private int size(Node<E> t)`              | æ±‚ä»¥ $t$ ä¸ºæ ¹ç»“ç‚¹çš„æ ‘å¤§å°           |

<br />

ä»¥ä¸‹æ˜¯äºŒå‰æ ‘ç»“ç‚¹åµŒå¥—ç±» $Node$ çš„æ¶æ„ã€‚

| ç±»æˆå‘˜/æ–¹æ³•                                           | æè¿°     |
| ----------------------------------------------------- | -------- |
| `public E element`                                    | ç»“ç‚¹æ•°æ® |
| `public Node<E> left`                                 | å·¦å­ç»“ç‚¹ |
| `public Node<E> right`                                | å³å­ç»“ç‚¹ |
| `public Node(E element)`                              | æ„é€ å™¨   |
| `public Node(E element, Node<E> left, Node<E> right)` | æ„é€ å™¨   |

<br />

#### ä¸»è¦æ–¹æ³•

åœ¨ç±»æ¶æ„è¡¨æ ¼ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ° BST å®ç°çš„ $set$ ç±» ($MyTreeSet$) ä¸»è¦åº”è¯¥åŒ…å«å“ªäº›æ–¹æ³•ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è®²è§£è¿™å…¶ä¸­çš„ä¸»è¦æ–¹æ³•ã€‚å…¶ä»–å®ç°ç®€å•çš„æ–¹æ³•åœ¨ã€Œç±»çš„å®ç°ä»£ç ã€ä¸­å‘ˆç°ã€‚

<br />

##### add

æ’å…¥ç»“ç‚¹æ“ä½œç”±æ’å…¥é©±åŠ¨æ–¹å’Œå…·ä½“æ’å…¥æ–¹æ³•å®Œæˆï¼Œå°†å€¼ä¸º $e$ çš„ç»“ç‚¹æ’å…¥åˆ°å½“å‰äºŒå‰æ ‘ä¸­å¹¶ä½¿å¾—æ’å…¥åä»ä¿æŒæŸ¥æ‰¾æ ‘æ€§è´¨ã€‚é€’å½’åœ°æ¯”è¾ƒ $e$ å’Œå½“å‰ç»“ç‚¹å€¼çš„å¤§å°ï¼Œæœ€å $e$ æ€»èƒ½ **ä½œä¸ºä¸€ä¸ªå¶å­ç»“ç‚¹** è¢«æ’å…¥åˆ°æ»¡è¶³æŸ¥æ‰¾æ ‘æ€§è´¨çš„ä½ç½®ã€‚

å¯¹äºå…·ä½“æ’å…¥æ–¹æ³•ï¼Œå½“åŸæ ‘ä¸º $null$ æ—¶è¿”å› `Node<>(e,null, null)` ç»™ $root$ ï¼Œå³æ•°æ®ä¸º $e$ çš„ç»“ç‚¹ä½œä¸ºæ ¹ç»“ç‚¹æ’å…¥ã€‚å½“åŸæ ‘ä¸ä¸º $null$ æ—¶ï¼Œ **æ’å…¥åè¿”å›åŸæ ¹** ã€‚

```java
public void add(E e) { // æ’å…¥ç»“ç‚¹é©±åŠ¨æ–¹æ³•
    root = add(e, root);
}
private Node<E> add(E e, Node<E> t){ // æ’å…¥ç»“ç‚¹
    if(t == null) return new Node<>(e,null, null);
    int cmp = e.compareTo(t.element);
    if(cmp < 0) t.left = add(e, t.left); // é€’è¿›ç›´åˆ°t.left == null
    else if(cmp > 0) t.right = add(e, t.right); // é€’è¿›ç›´åˆ°t.right == null
    return t; // ç­‰äºæ—¶ä¸æ’å…¥(ä»¥è¯¥æ ‘åªèƒ½å­˜æ”¾ä¸åŒçš„å…ƒç´ ä¸ºå‰æ)
}
```

<br />

##### remove

åˆ é™¤ç»“ç‚¹æ“ä½œç”±åˆ é™¤é©±åŠ¨æ–¹æ³•å’Œå…·ä½“åˆ é™¤æ–¹æ³•å®Œæˆï¼Œå°†æ•°æ®é¡¹ä¸º $e$ çš„ç»“ç‚¹åˆ é™¤å¹¶ä½¿å¾—åˆ é™¤åä»ä¿æŒæŸ¥æ‰¾æ ‘æ€§è´¨ã€‚

é¦–å…ˆï¼Œåœ¨é©±åŠ¨æ–¹æ³•ä¸­æ‰§è¡Œ $contains(e)$ ï¼Œè‹¥ä¸å­˜åœ¨ç›´æ¥è¿”å›ï¼Œå¦åˆ™åˆ é™¤ç›®æ ‡å­˜åœ¨ï¼Œè°ƒç”¨å…·ä½“åˆ é™¤æ–¹æ³•ï¼Œé€’å½’åœ°å¯»æ‰¾ $element$ ä¸º $e$ çš„ç»“ç‚¹ $t$ ï¼Œå¯¹å…¶æ‰§è¡Œ **æ‡’æƒ°åˆ é™¤** ã€‚åˆ é™¤ç›¸æ¯”å…¶ä»–æ“ä½œè¦å¤æ‚ä¸€äº›ï¼Œä»¥ä¸‹ä¸ºæ‰¾åˆ°æ—¶ç»“ç‚¹ $t$ çš„ä¸¤ç§æƒ…å½¢ã€‚

- æƒ…å½¢1: $t$ æœ‰å·¦å³ä¸¤ä¸ªå­ç»“ç‚¹ã€‚
- æƒ…å½¢2: $t$ æœ‰ä¸€ä¸ªæˆ–æ²¡æœ‰å­ç»“ç‚¹ã€‚

æƒ…å½¢1æ—¶ï¼Œæ‰¾åˆ° $t$ çš„å³å­æ ‘ä¸­æœ€å°ç»“ç‚¹ $min$ ï¼Œä»¤ `t.element = min.element` ï¼Œå³ç›¸å½“äºç”¨ $min$ æ›¿æ¢æ‰è¦åˆ é™¤çš„ $t$ ï¼Œç„¶åå¯¹å³å­æ ‘æ‰§è¡Œåˆ é™¤ $min$ çš„æ“ä½œï¼ˆç”±äºæ˜¯æœ€å°å€¼ï¼Œæ•…æ­¤åˆ é™¤å¿…å±äºæƒ…å½¢ 2ï¼‰ã€‚

æƒ…å½¢2æ—¶ï¼Œæ ¹æ®æ˜¯å¦æœ‰å·¦å­ç»“ç‚¹ï¼Œæ‰§è¡Œæ­¤è¯­å¥ `t = (t.left != null) ? t.left : t.right` ã€‚æœ‰å·¦å­ç»“ç‚¹æ—¶ `t = t.left`ï¼Œå³ç”¨è¿™ä¸ªå·¦å­ç»“ç‚¹å–ä»£ $t$ã€‚æ²¡æœ‰å·¦å­ç»“ç‚¹æ—¶ `t = t.right`ï¼Œè¡¨ç¤ºä»¥å³å­ç»“ç‚¹å–ä»£ $t$ï¼ˆåŒ…å«å³å­ç»“ç‚¹ä¹Ÿä¸ºç©ºçš„æƒ…å½¢ï¼Œåˆ™æ­¤æ—¶ `t = null`ï¼‰ã€‚

å¯¹äºå…·ä½“åˆ é™¤æ–¹æ³•ï¼Œå½“åŸæ ‘ä¸º $null$ æ—¶è¿”å› $t$ (å³ $root$ ) ç»™ $root$ ã€‚å½“åŸæ ‘ä¸ä¸º $null$ æ—¶ï¼Œåœ¨åˆ é™¤åé€’å½’åœ°è¿”å›åˆ°å½“å‰æ ¹ç»™ $root$ï¼ˆä¾‹å¦‚å½“æ ‘åªæœ‰æ ¹ç»“ç‚¹ï¼Œä¸”åˆ é™¤çš„å°±æ˜¯è¯¥æ ¹æ—¶ï¼Œ`root = null` ï¼‰ã€‚

```java
public void remove(E e) { // åˆ é™¤ç»“ç‚¹é©±åŠ¨æ–¹æ³•
    if (e == null) throw new IllegalArgumentException("argument to remove() is null");
    if (!contains(e)) return; // æ£€æµ‹åˆ é™¤ç›®æ ‡æ˜¯å¦å­˜åœ¨
    root = remove(e, root);
}
private Node<E> remove(E e, Node<E> t){ // æ‡’æƒ°åˆ é™¤ç»“ç‚¹
    if(t == null) return null;
    int cmp = e.compareTo(t.element);
    if(cmp < 0) t.left = remove(e, t.left); // é€’å½’åœ°åœ¨å·¦ä¾§å¯»æ‰¾
    else if(cmp > 0) t.right = remove(e, t.right); // é€’å½’åœ°åœ¨å³ä¾§å¯»æ‰¾
    // eç­‰äºt.elementï¼Œåˆ†ä¸¤ç§æƒ…å½¢
    else if(t.left != null && t.right != null) { // æƒ…å½¢1ï¼šè¯¥tçš„å·¦å³å­èŠ‚ç‚¹å‡ä¸ä¸ºnull
        t.element = first(t.right).element; // åœ¨å³å­æ ‘ä¸­æ‰¾min
        t.right = remove(t.element, t.right); // æ­¤æ—¶minå·²æ˜¯t.elementï¼Œå¿…ä¸ºæƒ…å½¢2
    }
    else t = (t.left != null) ? t.left : t.right; // æƒ…å½¢2: 1ä»¥å¤–çš„æƒ…å½¢
    return t;
}
```

<br />

##### first/last

æŸ¥æ‰¾å…·æœ‰æœ€å°/æœ€å¤§æ•°æ®çš„ç»“ç‚¹çš„æ“ä½œç”±é©±åŠ¨æ–¹æ³•å’Œå…·ä½“æ–¹æ³•å®ç°ã€‚æ ¹æ® BST æ€§è´¨ä¸€ç›´å‘å·¦/å‘å³å¯»æ‰¾å³å¯æ‰¾åˆ°æœ€å°/æœ€å¤§å€¼ã€‚ä»¥ä¸‹ä»¥é€’å½’æ–¹å¼å®ç° $first$ï¼Œä»¥è¿­ä»£æ–¹å¼å®ç° $last$ ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•çš„å®ç°å®¹æ˜“ç†è§£ï¼Œä¸èµ˜è¿°ã€‚å¦‚ä¸‹å±•ç¤º $first$ çš„å®ç°ï¼Œ$last$ çš„å®ç°è¯·çœ‹ã€Œç±»çš„å®ç°ä»£ç ã€ã€‚

```java
public E first() { // æŸ¥æ‰¾æœ€å°ç»“ç‚¹é©±åŠ¨æ–¹æ³•
    if(isEmpty()) throw new NoSuchElementException();
    return first(root).element;
}
private Node<E> first(Node<E> t){ // è¿”å›æ ‘çš„æœ€å°èŠ‚ç‚¹(å°¾é€’å½’æ–¹å¼)
    if(t.left == null) return t;
    return first(t.left);
}
```

<br />

##### floor/ceiling

$floor$ æ–¹æ³•ç”¨äºæŸ¥æ‰¾å°äºç­‰äºæŒ‡å®šå…ƒç´ ä¸­çš„æœ€å¤§è€…ï¼Œ$ceiling$ æ–¹æ³•ç”¨äºæŸ¥æ‰¾å¤§äºç­‰äºæŒ‡å®šå…ƒç´ ä¸­çš„æœ€å°è€…ï¼Œå‡ç”±é©±åŠ¨æ–¹æ³•å’Œå…·ä½“æ–¹æ³•å®ç°ã€‚å…¶å®ç°æ–¹å¼ä¹Ÿæ˜¯æ ¹æ® BST æ€§è´¨å‘å·¦/å‘å³å¯»æ‰¾ç›®æ ‡ã€‚

ä»¥ $floor$ ä¸ºä¾‹ï¼Œè¯´æ˜å¦‚ä¸‹ã€‚

1. `if (cmp == 0) return x;` è‹¥å½“å‰å…ƒç´  $x$ ä¸ç›®æ ‡å…ƒç´ ç›¸ç­‰ï¼Œåˆ™ $x$ å³ä¸ºæ‰€æ±‚ç›´æ¥è¿”å›ã€‚
2. `if (cmp < 0) return floor(x.left, e);` è‹¥ $e$ å°äºå½“å‰å…ƒç´  $x$ï¼Œè¯´æ˜ç›®æ ‡å…ƒç´ åœ¨ $x$ çš„å·¦å­æ ‘ä¸­ï¼Œä¼ å…¥ $x.left$ é€’å½’è°ƒç”¨ $floor$ ã€‚
3. `Node<E> t = floor(x.right, e);` å¦åˆ™æ­¤æ—¶ $e$ å¤§äº $x$ ï¼Œåœ¨ $x$ çš„å³å­æ ‘ä¸­æ‰¾æœ€å¤§è€…ï¼Œå³ä¸ºæ‰€æ±‚ã€‚

å¦‚ä¸‹å±•ç¤º $floor$ çš„å®ç°ï¼Œ$ceiling$ çš„å®ç°è¯·çœ‹ã€Œç±»çš„å®ç°ä»£ç ã€ã€‚

```java
public E floor(E e) { // æŸ¥æ‰¾å°äºç­‰äº e çš„æœ€å¤§å…ƒç´ é©±åŠ¨æ–¹æ³•
    if (e == null) throw new IllegalArgumentException("argument to floor() is null");
    if (isEmpty()) throw new NoSuchElementException("calls floor() with empty symbol table");
    Node<E> x = floor(root, e);
    if (x == null) throw new NoSuchElementException("argument to floor() is too small");
    else return x.element;
}
private Node floor(Node<E> x, E e) { // å°äºç­‰äº e ä¸­æœ€å¤§è€…
    if (x == null) return null;
    int cmp = e.compareTo(x.element);
    if (cmp == 0) return x;
    if (cmp < 0) return floor(x.left, e);
    Node<E> t = floor(x.right, e);
    if (t != null) return t;
    else return x;
}
```

ç±»ä¼¼åœ°ï¼Œ$lower$ æ–¹æ³•ç”¨äºæŸ¥æ‰¾ä¸¥æ ¼å°äºæŒ‡å®šå…ƒç´ ä¸­çš„æœ€å¤§è€…ï¼Œ$higher$ æ–¹æ³•ç”¨äºæŸ¥æ‰¾ä¸¥æ ¼å¤§äºæŒ‡å®šå…ƒç´ çš„æœ€å°è€…ã€‚äºŒè€…çš„å®ç°æ–¹å¼ä¸ $floor/ceiling$ éå¸¸ç±»ä¼¼ï¼Œåªéœ€è¦å°†ç­‰äºçš„æƒ…å½¢ä¸éœ€è¦é€’å½’çš„æƒ…å½¢åˆå†™å³å¯ï¼Œå…·ä½“è¯·çœ‹ã€Œç±»çš„å®ç°ä»£ç ã€ã€‚ 

<br />

##### contains

å¯»æ‰¾æ ‘ä¸­æ˜¯å¦åŒ…å«æ•°æ®é¡¹ä¸º $e$ çš„ç»“ç‚¹çš„æ“ä½œç”±ç›¸åº”çš„é©±åŠ¨æ–¹æ³•å’Œå…·ä½“æ–¹æ³•å®ç°ã€‚æ ¹æ®äºŒå‰æŸ¥æ‰¾æ ‘çš„æ€§è´¨ä»¥é€’å½’æ–¹å¼ä¸€ç›´å‘å·¦/å‘å³å¯»æ‰¾ã€‚æ‰¾åˆ°è¿”å› $true$ ï¼Œå¦åˆ™è¿”å› $false$ ã€‚

```java
public boolean contains(E e) { // åˆ¤æ–­æ˜¯å¦åŒ…å«å€¼ä¸ºeçš„å…ƒç´ çš„ç»“ç‚¹çš„é©±åŠ¨æ–¹æ³•
    return contains(e, root);
}
private boolean contains(E e, Node<E> t) { // åˆ¤æ–­æ ‘ä¸­æ˜¯å¦æœ‰æŒ‡å®šå…ƒç´ çš„èŠ‚ç‚¹
    if(t == null) return false;
    int cmp = e.compareTo(t.element);
    if(cmp < 0) return contains(e, t.left);
    else if(cmp > 0) return contains(e, t.right);
    else return true;
}
```

<br />

#### æ—¶ç©ºå¤æ‚åº¦

äºŒå‰æŸ¥æ‰¾æ ‘çš„å¹³å‡æ·±åº¦ä¸º $O(logn)$ ï¼Œå› æ­¤ä¸Šè¿°ä»‹ç»çš„ä¸»è¦æ–¹æ³• **å¹³å‡æ—¶é—´å¤æ‚åº¦** å‡ä¸º $O(logn)$ ã€‚å½“æ ‘ä¸ºé“¾çŠ¶æ—¶ï¼Œé€€åŒ–ä¸ºé“¾è¡¨å½¢å¼ï¼Œè¾¾åˆ°æœ€åæ—¶é—´å¤æ‚åº¦ $O(n)$ ã€‚è‹¥æ–¹æ³•ä»¥é€’å½’å®ç°ï¼Œåˆ™ç©ºé—´å¤æ‚åº¦å–å†³äºé€’å½’æ·±åº¦ $O(logn)$ ï¼Œè‹¥ä»¥è¿­ä»£æ–¹å¼å®ç°åˆ™ç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ ã€‚

| æ–¹æ³•                                                      | å¹³å‡æ—¶é—´  | æœ€åæ—¶é—´ |
| --------------------------------------------------------- | --------- | -------- |
| add/remove/first/last/floor/ceiling/lower/higher/contains | $O(logn)$ | $O(n)$   |

> BST å¹³å‡æ·±åº¦ä¸º $O(logn)$ çš„è¯æ˜è§æ­¤[è®ºæ–‡](http://luc.devroye.org/devroye_reed_1995_variance_height_random_binary_search_tree.pdf)ã€‚

<br />

#### ç±»çš„å®ç°ä»£ç 

```java
/**
 * äºŒå‰æŸ¥æ‰¾æ ‘ç±» MyTreeSet
 */
class MyTreeSet<E extends Comparable<? super E>>{
    private Node<E> root; // å”¯ä¸€å­—æ®µï¼Œæ ¹èŠ‚ç‚¹
    public MyTreeSet() {} // æ— å‚æ„é€ å™¨
    public void clear() { // æ ‘ç½®ç©º
        root = null;
    }
    public boolean isEmpty() { // åˆ¤æ ‘ç©º
        return root == null;
    }
    public void add(E e) { // æ’å…¥ç»“ç‚¹é©±åŠ¨æ–¹æ³•
        root = add(e, root);
    }
    public void remove(E e) { // åˆ é™¤ç»“ç‚¹é©±åŠ¨æ–¹æ³•
        if (e == null) throw new IllegalArgumentException("argument to remove() is null");
        if (!contains(e)) return; // æ£€æµ‹åˆ é™¤ç›®æ ‡æ˜¯å¦å­˜åœ¨
        root = remove(e, root);
    }
    public E first() { // æŸ¥æ‰¾æœ€å°ç»“ç‚¹é©±åŠ¨æ–¹æ³•
        if(isEmpty()) throw new NoSuchElementException();
        return first(root).element;
    }
    public E last(){ // æŸ¥æ‰¾æœ€å¤§ç»“ç‚¹é©±åŠ¨æ–¹æ³•
        if(isEmpty()) throw new NoSuchElementException();
        return last(root).element;
    }
    public E floor(E e) { // æŸ¥æ‰¾å°äºç­‰äº e çš„æœ€å¤§å…ƒç´ é©±åŠ¨æ–¹æ³•
        if (e == null) throw new IllegalArgumentException("argument to floor() is null");
        if (isEmpty()) throw new NoSuchElementException("calls floor() with empty symbol table");
        Node<E> x = floor(root, e);
        if (x == null) throw new NoSuchElementException("argument to floor() is too small");
        else return x.element;
    }
    public E ceiling(E e) { // æŸ¥æ‰¾å¤§äºç­‰äº e çš„æœ€å°å…ƒç´ é©±åŠ¨æ–¹æ³•
        if (e == null) throw new IllegalArgumentException("argument to ceiling() is null");
        if (isEmpty()) throw new NoSuchElementException("calls ceiling() with empty symbol table");
        Node<E> x = ceiling(root, e);
        if (x == null) throw new NoSuchElementException("argument to ceiling() is too large");
        else return x.element;
    }
    public E lower(E e) { // æŸ¥æ‰¾ä¸¥æ ¼å°äº e çš„æœ€å¤§å…ƒç´ é©±åŠ¨æ–¹æ³•
        if (e == null) throw new IllegalArgumentException("argument to lower() is null");
        if (isEmpty()) throw new NoSuchElementException("calls lower() with empty symbol table");
        Node<E> x = lower(root, e);
        if (x == null) throw new NoSuchElementException("argument to lower() is too small");
        else return x.element;
    }
    public E higher(E e) { // æŸ¥æ‰¾ä¸¥æ ¼å¤§äº e çš„æœ€å°å…ƒç´ é©±åŠ¨æ–¹æ³•
        if (e == null) throw new IllegalArgumentException("argument to higher() is null");
        if (isEmpty()) throw new NoSuchElementException("calls higher() with empty symbol table");
        Node<E> x = higher(root, e);
        if (x == null) throw new NoSuchElementException("argument to higher() is too large");
        else return x.element;
    }
    public boolean contains(E e) { // åˆ¤æ–­æ˜¯å¦åŒ…å«å€¼ä¸ºeçš„å…ƒç´ çš„ç»“ç‚¹çš„é©±åŠ¨æ–¹æ³•
        return contains(e, root);
    }
    public void printTree() { // ä¸­åºéå†æ‰“å°
        if (isEmpty()) System.out.println("Empty tree");
        else printTree(root);
    }
    public int size() { // æ±‚æ ‘çš„ä¸ªæ•°é©±åŠ¨æ–¹æ³•
        return size(root);
    }
    public int height() { // æ±‚æ ‘çš„é«˜åº¦é©±åŠ¨æ–¹æ³•
        return height(root);
    }
    private Node<E> add(E e, Node<E> t){ // æ’å…¥ç»“ç‚¹
        if(t == null) return new Node<>(e,null, null);
        int cmp = e.compareTo(t.element);
        if(cmp < 0) t.left = add(e, t.left); // é€’è¿›ç›´åˆ°t.left == null
        else if(cmp > 0) t.right = add(e, t.right); // é€’è¿›ç›´åˆ°t.right == null
        return t; // ç­‰äºæ—¶ä¸æ’å…¥(ä»¥è¯¥æ ‘åªèƒ½å­˜æ”¾ä¸åŒçš„å…ƒç´ ä¸ºå‰æ)
    }
    private Node<E> remove(E e, Node<E> t){ // æ‡’æƒ°åˆ é™¤ç»“ç‚¹
        if(t == null) return null;
        int cmp = e.compareTo(t.element);
        if(cmp < 0) t.left = remove(e, t.left); // é€’å½’åœ°åœ¨å·¦ä¾§å¯»æ‰¾
        else if(cmp > 0) t.right = remove(e, t.right); // é€’å½’åœ°åœ¨å³ä¾§å¯»æ‰¾
        // eç­‰äºt.elementï¼Œåˆ†ä¸¤ç§æƒ…å½¢
        else if(t.left != null && t.right != null) { // æƒ…å½¢1ï¼šè¯¥tçš„å·¦å³å­èŠ‚ç‚¹å‡ä¸ä¸ºnull
            t.element = first(t.right).element; // åœ¨å³å­æ ‘ä¸­æ‰¾min
            t.right = remove(t.element, t.right); // æ­¤æ—¶minå·²æ˜¯t.elementï¼Œå¿…ä¸ºæƒ…å½¢2
        }
        else t = (t.left != null) ? t.left : t.right; // æƒ…å½¢2: 1ä»¥å¤–çš„æƒ…å½¢
        return t;
    }
    private Node<E> first(Node<E> t){ // è¿”å›æ ‘çš„æœ€å°èŠ‚ç‚¹(å°¾é€’å½’æ–¹å¼)
        if(t.left == null) return t;
        return first(t.left);
    }
    private Node<E> last(Node<E> t){ // è¿”å›æ ‘çš„æœ€å¤§èŠ‚ç‚¹(å¾ªç¯æ–¹å¼)
        while(t.right != null) t = t.right;
        return t;
    }
    private Node floor(Node<E> x, E e) { // å°äºç­‰äº e ä¸­æœ€å¤§è€…
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp == 0) return x;
        if (cmp < 0) return floor(x.left, e);
        Node<E> t = floor(x.right, e);
        if (t != null) return t;
        else return x;
    }
    private Node<E> ceiling(Node<E> x, E e) { // å¤§äºç­‰äº e ä¸­çš„æœ€å°è€…
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp == 0) return x;
        if (cmp > 0)  return ceiling(x.right, e);
        Node<E> t = ceiling(x.left, e);
        if (t != null) return t;
        else return x;
    }
    private Node lower(Node<E> x, E e) { // å°äº e ä¸­æœ€å¤§è€…
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp <= 0) return lower(x.left, e);
        Node<E> t = lower(x.right, e);
        if (t != null) return t;
        else return x;
    }
    private Node<E> higher(Node<E> x, E e) { // å¤§äº e ä¸­çš„æœ€å°è€…
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp >= 0)  return higher(x.right, e);
        Node<E> t = higher(x.left, e);
        if (t != null) return t;
        else return x;
    }
    private boolean contains(E e, Node<E> t) { // åˆ¤æ–­æ ‘ä¸­æ˜¯å¦æœ‰æŒ‡å®šå…ƒç´ çš„èŠ‚ç‚¹
        if(t == null) return false;
        int cmp = e.compareTo(t.element);
        if(cmp < 0) return contains(e, t.left);
        else if(cmp > 0) return contains(e, t.right);
        else return true;
    }
    private void printTree(Node<E> t) { // ä¸­åºéå†æ‰“å°æ ‘
        if(t != null) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
    private int height(Node<E> t) { // è¿”å›ä»¥tä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘çš„é«˜åº¦
        if(t == null) return -1;
        else return 1 + Math.max(height(t.left), height(t.right));
    }
    private int size(Node<E> t) { // é€’å½’åœ°éå†æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œè¿”å›èŠ‚ç‚¹æ€»æ•°
        if(t != null) {
            if(t.left != null && t.right != null) {
                return 1 + size(t.left) + size(t.right);
            }
            else {
                return t.left != null ? 1 + size(t.left) : 1 + size(t.right);
            }
        }
        return 0;
    }
    /**
     * äºŒå‰æ ‘èŠ‚ç‚¹åµŒå¥—ç±»
     */
    private static class Node<E>{
        public E element;
        public Node<E> left, right;
        public Node(E element, Node<E> left, Node<E> right){
            this.element = element;
            this.left = left;
            this.right = right;
        }
    }
}
```

<br />

#### æµ‹è¯•ä»£ç 

```java
package com.yukiyama;
import java.util.NoSuchElementException;

public class MyTreeSetDemo {

    public static void main(String[] args) {
        MyTreeSet<Integer> t = new MyTreeSet<>( );
        // 10 98 61 13 8 20 48 29 47 74
        /*
         *            10
         *        8       98
         *             61
         *          13    74
         *            20
         *              48
         *            29
         *              47
         */
        int[] elements = {10,98,61,13,8,20,48,29,47,74};
        for(int e : elements) t.add(e);
        t.add(10);
        t.printTree(); // è¾“å‡º8 10 13 20 29 47 48 61 74 98
        System.out.printf("size: %d, height: %d, min: %d, max: %d\n", t.size(), t.height(), t.first(), t.last());
        System.out.printf("has 47? %s, has 100? %s\n", t.contains(47), t.contains(100));
        System.out.printf("floor(9): %s, floor(10): %s, ceiling(73): %s, ceiling(98): %s\n", t.floor(9), t.floor(10), t.ceiling(73), t.ceiling(98));
        System.out.printf("lower(9): %s, lower(10): %s, higher(73): %s, higher(61): %s\n", t.lower(9), t.lower(10), t.higher(73), t.higher(61));
        t.remove(47); t.remove(48); t.remove(61);
        t.printTree();
        System.out.println("is empty: " + t.isEmpty()); // è¾“å‡ºfalse
        t.clear();
        System.out.println("is empty: " + t.isEmpty()); // è¾“å‡ºtrue
        System.out.printf("size: %d, height: %d\n", t.size(), t.height());// è¾“å‡º0
    }

}
```

<br />